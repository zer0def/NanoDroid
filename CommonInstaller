#!/sbin/sh

VERSION=23.2.99999999
NANODROID_UPGRADE=0
INSTALL_SUCCESS=TRUE
NANODROID_LIST=/system/addon.d/NanoDroid_FileList
INSTPART=/system

STORAGE=/data/media/0
curdate="$(date +%Y%m%d_%H.%M.%S)"
nanodroid_logfile="${STORAGE}/nanodroid_logs/${MODID}_${VERSION}_log_${curdate}.log"

config_locations="${STORAGE} /external_sd /sdcard /sdcard1 /data /system/addon.d /tmp"

nanodroid_all_init='"10_sqlite 20_fstrim 30_logcat 40_external_sd 50_logscleaner"'

##########################################################################################
# NanoDroid Installer Setup Function
##########################################################################################

setup_installer () {
	detect_bootmode
	detect_outfd
	! "${BOOTMODE}" && [ "${MODID}" = "NanoDroid" ] && check_space
	show_progress 1.0 0

	show_banner
	set_progress 0.1

	unpack_zip
	setup_busybox
	mount_partitions
	detect_arch
	set_progress 0.2

	if "${BOOTMODE}"; then
		media_rw="$(grep "^/dev/block.*/mnt/media_rw" /proc/mounts | cut -d " " -f 2 | cut -d "/" -f 4)"
		ext_storage="/storage/${media_rw}"

		[ -r "${ext_storage}" ] && config_locations="${ext_storage} ${config_locations}"
	fi

	[ -n "${1}" ] && get_cfg_setup
	[ -n "${2}" ] && get_cfg_overlay
	[ -n "${3}" ] && get_cfg_apps

	detect_mode
	set_progress 0.3
}

##########################################################################################
# Misc. Functions
##########################################################################################

##########################################################################################
# Debug Echo: only echo in TWRP, in Magisk Manager print to logfile
##########################################################################################

decho () {
	mkdir -p "${STORAGE}/nanodroid_logs"

	if "${BOOTMODE}"; then
		echo "${@}" >> "${nanodroid_logfile}"
	else
		echo "${@}"
	fi
}

##########################################################################################
# use print_info() instead of ui_print() to avoid spamming Magisk Manager output
##########################################################################################

print_info () {
	if "${BOOTMODE}"; then
		echo "${@}"
		decho "${@}"
	else
		echo -e "ui_print ${@}" >> "/proc/self/fd/${OUTFD}"
		echo -e "ui_print" >> "/proc/self/fd/${OUTFD}"
	fi
}

show_progress () {
	"${BOOTMODE}" || echo "progress ${1} ${2}" >> "/proc/self/fd/${OUTFD}"
}

set_progress () {
	"${BOOTMODE}" || echo "set_progress ${1}" >> "/proc/self/fd/${OUTFD}"
}

##########################################################################################
# Error out with proper cleanup
##########################################################################################

error () {
	print_info " !!"
	print_info "${@}"
	print_info " !!"

	if is_mounted /data; then
		[ "${MODE}" = "MAGISK" ] && rm -rf "${MODPATH}"

		installer_cleanup_env

		INSTALL_SUCCESS=FALSE
		nanodroid_storelogs
	fi

	"${BOOTMODE}" || umount_partitions

	exit 1
}

##########################################################################################
# Taken from Magisk, check where to print to
##########################################################################################

detect_outfd () {
	if [ -z "${OUTFD}" ] || readlink "/proc/${$}/fd/${OUTFD}" | grep -q /tmp; then
		# We will have to manually find out OUTFD
		for FD in `ls "/proc/${$}/fd"`; do
			if readlink "/proc/${$}/fd/${FD}" | grep -q pipe; then
				if ps | grep -v grep | grep -q " 3 ${FD} "; then
					OUTFD="${FD}"
					break
				fi
			fi
		done
	fi
}

##########################################################################################
# XXX - unused - Check if enough free space in /dev/tmp
##########################################################################################

check_space () {
	space_required=524288
	space_available="$(df /dev 2>/dev/null | awk '/tmpfs/{print $4}')"

	decho "  required space : ${space_required}"
	decho "  available space: ${space_available}"

	if [ "${space_available}" -lt "${space_required}" ]; then
		error "Less than 512 MB free space availabe from TWRP!"
	fi
}

##########################################################################################
# Taken from Magisk, check whether we're in Magisk Manager or TWRP
##########################################################################################

detect_bootmode () {
	[ -z "${BOOTMODE}" ] && ps | grep zygote | grep -qv grep && BOOTMODE=true
	[ -z "${BOOTMODE}" ] && ps -A 2>/dev/null | grep zygote | grep -qv grep && BOOTMODE=true
	[ -z "${BOOTMODE}" ] && BOOTMODE=false
}

##########################################################################################
# Taken from Magisk, grep build_props / /proc/cmdline for value
##########################################################################################

grep_prop () {
	sed -n "s/^${1}=//p" /system/build.prop "${2}" | head -n 1
}

grep_cmdline () {
	local REGEX="s/^${1}=//p"
	sed -E 's/ +/\n/g' /proc/cmdline | \
		sed -n "${REGEX}" 2>/dev/null
}

##########################################################################################
# Set permissions for installed files
##########################################################################################

set_perm () {
	chown "${2}:${3}" "${1}" || error "failed change owner for ${1}"
	chmod "${4}" "${1}" || error "failed to change mode for ${1}"

	if [ -n "${5}" ]; then
		chcon "${5}" "${1}" 2>/dev/null
	else	chcon 'u:object_r:system_file:s0' "${1}" 2>/dev/null
	fi
}

set_perm_recursive () {
	find "${1}" -type d 2>/dev/null | while read dir; do
		set_perm "${dir}" "${2}" "${3}" "${4}" "${6}"
	done
	find "${1}" -type f 2>/dev/null | while read file; do
		set_perm "${file}" "${2}" "${3}" "${5}" "${6}"
	done
}

set_perm_data () {
	if [ "${1}" = "-r" ]; then
		decho "    perm: data [recursive] {${2}}"
		set_perm_recursive "${2}" 0 0 0755 0644
	else
		decho "    perm: data [single] {${1}}"
		set_perm "${1}" 0 0 0644
	fi
}

set_perm_bin () {
	if [ "${1}" = "-r" ]; then
		decho "    perm: exec [recursive] {${2}}"
		set_perm_recursive "${2}" 0 0 0755 0755
	else
		decho "    perm: exec [single] {${1}}"
		set_perm "${1}" 0 0 0755
	fi
}

##########################################################################################
# Taken from Magisk, mount functions
# Modified for NanoDroid
##########################################################################################

is_mounted () {
	grep -q " $(readlink -f "${1}") " /proc/mounts 2>/dev/null
	return "${?}"
}

##########################################################################################
# taken from Magisk, with minor modifications for NanoDroid
# mount partitions
##########################################################################################

toupper() {
	echo "${@}" | tr '[:lower:]' '[:upper:]'
}

find_block () {
	local block partname devname device

	for block in "${@}"; do
		block="${block}${SLOT}"
		device="$(find /dev/block \( -type b -o -type c -o -type l \) -name "${block}" | head -n 1)"

		if [ -n "${device}" ]; then
			readlink -f "${device}"
			return 0
		fi
	done

	for block in "${@}"; do
		block="${block}${SLOT}"
		for uevent in /sys/dev/block/*/uevent; do
			partname="$(awk -F= '/PARTNAME/{print $2}' "${uevent}")"
			devname="$(awk -F= '/DEVNAME/{print $2}' "${uevent}")"
			if [ "$(toupper "${block}")" = "$(toupper "${partname}")" ]; then
				echo "/dev/block/${devname}"
				return 0
			fi
		done
	done

	for block in "${@}"; do
		block="${block}${SLOT}"
		device="$(find /dev \( -type b -o -type c -o -type l \) -maxdepth 1 -iname "${block}" | head -n 1)"
		if [ -n "${device}" ]; then
			readlink -f "${device}"
			return 0
		fi
	done

	return 1
}

mount_partitions () {
	if ! "${BOOTMODE}"; then
		sed -i 's/\([\t ,]\)ro\([\t ,]\)/\1rw\2/g' /etc/fstab
		VENDOR_COMPAT=FALSE
		SYSTEM_AS_ROOT=FALSE

		PRODUCT_BLOCK="$(find_block product)"
		SYSEXT_BLOCK="$(find_block system_ext)"

		SLOT="$(grep_cmdline androidboot.slot_suffix)"
		if [ -z "${SLOT}" ]; then
			SLOT="$(grep_cmdline androidboot.slot)"
			[ -z "${SLOT}" ] || SLOT="_${SLOT}"
		fi
		[ -z "${SLOT}" ] && DEVICE_AB=FALSE || DEVICE_AB=TRUE
		decho " INFO: #1 [SLOT] ${SLOT}"

		is_mounted /data || mount /data || decho "failed to mount /data!"

		mount -o bind /dev/urandom /dev/random

		SYSTEM_BLOCK="$(find_block system app)"
		decho " INFO: #5 [SYSTEM_BLOCK] ${SYSTEM_BLOCK}"

		[ -z "${SYSTEM_BLOCK}" ] && error "failed to detect block device for /system"

		if is_mounted /system_root; then
			umount /system &>/dev/null
			umount /system_root &>/dev/null
		fi

		mkdir -p /system /system_root
		mount -o rw "${SYSTEM_BLOCK}" /system

		if [ -f /system/build.prop ]; then
			SYSTEM=/system
		elif [ -f /system/system/build.prop -o -f /system/init -o -L /system/init ]; then
			SYSTEM_AS_ROOT=true
			SYSTEM=/system/system
			if ! mount --move /system /system_root; then
				umount "${SYSTEM_BLOCK}"
				mount -o rw "${SYSTEM_BLOCK}" /system_root
			fi
			mount -o bind /system_root/system /system
		fi

		VENDOR_BLOCK="$(find_block vendor vnr cust)"
		decho " INFO: #7 [VENDOR_BLOCK] ${VENDOR_BLOCK}"

		[ -z "${VENDOR_BLOCK}" ] && error "failed to detect block device for /vendor"

		! is_mounted /vendor && mount -o ro /vendor
		! is_mounted /vendor && mount -o ro "${VENDOR_BLOCK}" /vendor

		if [[ ! "$(is_mounted /vendor)" && -d /system/vendor ]]; then
			### XXX work-around required for some devices
			VENDOR_COMPAT=TRUE
			mount -o ro "${VENDOR_BLOCK}" /vendor
		fi

		decho " INFO: #8 [prop]"
		ls -l /system/*.prop

		if [ -n "${PRODUCT_BLOCK}" ]; then
			is_mounted /product && umount /product
			umount "${PRODUCT_BLOCK}"
			mkdir -p /system/product
			mount -o rw "${PRODUCT_BLOCK}" /system/product
			mount -o bind /system/product /product
			decho " INFO: #-1 [PRODUCT_BLOCK] ${PRODUCT_BLOCK}"
		fi

		if [ -n "${SYSEXT_BLOCK}" ]; then
			is_mounted /system_ext && umount /system_ext
			umount "${SYSEXT_BLOCK}"
			mkdir -p /system/system_ext
			mount -o rw "${SYSEXT_BLOCK}" /system/system_ext
			mount -o bind /system/system_ext /system_ext
			decho " INFO: #-1 [SYSEXT_BLOCK] ${SYSEXT_BLOCK}"
		fi

		[ -d /system/apex ] && mount_apex
	fi

	[ ! -f /system/build.prop ] && error "failed to mount /system (unsupported A/B device?)"

	export ANDROID_RUNTIME_ROOT=/apex/com.android.runtime
	export ANDROID_TZDATA_ROOT=/apex/com.android.tzdata
	export ANDROID_ART_ROOT=/apex/com.android.art
	export ANDROID_I18N_ROOT=/apex/com.android.i18n
}

##########################################################################################
# taken from Magisk, with minor modifications for NanoDroid
# mount APEX directories or images
##########################################################################################

mount_apex () {
	mkdir -p /apex
	local pattern='s/.*"name":[^"]*"\([^"]*\).*/\1/p'
	mount -t tmpfs tmpfs /apex -o mode=755

	for apex in /system/apex/*; do
		apex_loop="/dev/loop_apex_$(basename "${apex}" .apex)"

		if [ -f "${apex}" ]; then
			unzip -oq "${apex}" apex_payload.img -d /apex
			apex_mount="$(unzip -qp "${apex}" apex_manifest.pb | strings | head -n 1)"
			[ -z "${apex_mount}" ] && apex_mount="$(unzip -qp "${apex}" apex_manifest.json | sed -n "${pattern}")"
			[ -z "${apex_mount}" ] && continue

			mkdir -p "${apex_mount}"
			mount_apex_loop "${apex_mount}" || error "APEX loop setup failed!"
		elif [ -d "${apex}" ]; then
			if [ -f "${apex}/apex_manifest.json" ]; then
				apex_mount="/apex/$(sed -n "${pattern}" "${apex}/apex_manifest.json")"
			elif [ -f "${apex}/apex_manifest.pb" ]; then
				apex_mount="/apex/$(strings "${apex}/apex_manifest.pb" | head -n 1)"
			else
				continue
			fi
			mkdir -p "${apex_mount}"
			mount -o bind "${apex}" "${apex_mount}"
		fi
	done

	echo " INFO: #10 [APEX [ALL]] $(ls /system/apex/*)"
}

##########################################################################################
# taken from Magisk, with minor modifications for NanoDroid
# helper function for mounting APEX directories or images
##########################################################################################

mount_apex_loop () {
	local number=0
	local minorx=1
	local loop

	[ -e /dev/block/loop1 ] && minorx="$(stat -Lc '%T' /dev/block/loop1)"

	apex_mount="${1}"

	decho " *** mount_apex_loop [apex_mount]: ${apex_mount}"

	while [ "${number}" -lt 64 ]; do
		loop=/dev/block/loop${number}
		[ -e "${loop}" ] || mknod "${loop}" b 7 "$((number * minorx))"

		if losetup "${loop}" /apex/apex_payload.img 2>/dev/null; then
			decho " *** mount_apex_loop [loop]: ${loop}"
			if mount -text4 -oro,noatime "${loop}" "${apex_mount}"; then
				rm -f /apex/apex_payload.img
				break
			fi
		fi

		number="$((number + 1))"
	done
}

##########################################################################################
# unmount partitions
##########################################################################################

umount_partitions () {
	umount -l /product 2>/dev/null
	umount -l /system/product 2>/dev/null
	umount -l /system_ext 2>/dev/null
	umount -l /system/system_ext 2>/dev/null
	umount -l /system_root 2>/dev/null
	umount -l /system 2>/dev/null
	umount -l /system/vendor 2>/dev/null
	umount -l /vendor 2>/dev/null
	umount -l /dev/random 2>/dev/null

	mount | awk '/ \/apex/{print $1 " " $3}' | while read apex_loop apex_mount; do
		umount -l "${apex_mount}" 2>/dev/null
		losetup -d "${apex_loop}" 2>/dev/null
	done

	rm -rf /apex

	unset ANDROID_RUNTIME_ROOT
	unset ANDROID_TZDATA_ROOT
	unset ANDROID_ART_ROOT
	unset ANDROID_I18N_ROOT
}

##########################################################################################
# parse output from "aapt dump xmltree" back to xml
##########################################################################################

parse_aapt_dump_xmltree(){
	local i step indent prev_indent cur_type prev_type entity_stack key value tmp
	while IFS=$'\n' read -r i; do
		cur_type="$(echo "${i}" | awk '{print $1}')"
		case "${cur_type}" in
			E:)  # entity
				indent="$(echo "${i}" | awk -F'[^ ]' '{print length($1)}')"
				[ -z "${prev_type}" ] || [ "${prev_type}" = "C:" ] || echo -n ">"
				[ -z "${prev_type}" ] || [ "$((${prev_indent:=0}-${indent}))" -lt 0 ] || for j in $(seq "$((${prev_indent:=0}-${indent}))" "-${step:=2}" "$((${indent}-${step}))"); do
					echo -ne "\n</${entity_stack##* }>"
					entity_stack="${entity_stack% *}"
				done
				echo -ne "\n<$(echo -n "${i}" | awk '{print $2}')"
				entity_stack="${entity_stack} $(echo "${i}" | awk '{print $2}')"
				prev_indent="${indent}"
				;;
			A:)  # attribute
				key="$(echo "${i}" | awk '{print $2}' | awk -F= '{print $1}')"
				value="${i#*=}"
				case "${value}" in
					"(type 0x12)"*) [ "${value#*)}" = "0x0" ] && value='"false"' || value='"true"';;
					"(type 0x10)"*) value="$(printf '%d' "${value#*)}")";;
					*) value="${value% \(Raw:*}"
				esac
				echo -n " ${key}=${value}"
				unset key value
				;;
			C:)  # content
				tmp="${i#*C: \"}"
				echo -n ">${tmp%*\"}"
				unset tmp
				;;
		esac
		prev_type="${cur_type}"
	done <&0
	[ "${prev_type}" = "C:" ] || echo -n ">"

	until [ -z "${entity_stack}" ]; do
		echo -ne "\n</${entity_stack##* }>"
		entity_stack="${entity_stack% *}"
	done
}

##########################################################################################
# sign package with test keys
##########################################################################################

#byte_split(){ local i; for i in $(seq 0 2 $((${#1}-1))); do echo "${1:${i}:2}"; done; }
#hex2bin(){ local i; for i in $(seq 0 2 $((${#1}-1))); do printf "\x${1:${i}:2}"; done; }
byte_split(){ echo -n "${1}" | fold -w2; }
hex2bin(){ local i; for i in $(echo -n "${1}" | fold -w2); do printf '%b' "\0$(printf '%o' "0x${i}")"; done; }
jar_sign(){
	local tmpdir="${TMPDIR}/$(tr -cd '0-9a-z' 2>/dev/null </dev/urandom | head -c8)" apk="${1}" i

	mkdir -p "${tmpdir}/META-INF"
	cd "${tmpdir}"; echo A | unzip -qo "${apk}"
	cat <<EOF >"${tmpdir}/META-INF/MANIFEST.MF"
Manifest-Version: 1.0
Built-By: NanoDroid
Created-By: 1.0 (Android)

EOF
	for i in $(find "${tmpdir}" -type f); do
		echo "${i}" | grep -qvE "^${tmpdir}/META-INF/" || continue
		cat <<EOF >>"${tmpdir}/META-INF/MANIFEST.MF"
Name: ${i#${tmpdir}/*}
SHA-256-Digest: $(hex2bin "$(sha256sum "${i}" | awk '{print $1}')" | base64 | tr -d '[:space:]')

EOF
	done

	cat <<EOF >"${tmpdir}/META-INF/CERT.SF"
Signature-Version: 1.0
Created-By: 1.0 (Android)
SHA-256-Digest-Manifest: $(hex2bin "$(sha256sum "${tmpdir}/META-INF/MANIFEST.MF" | awk '{print $1}')" | base64 | tr -d '[:space:]')
X-Android-APK-Signed: 2, 3

EOF
	for i in $(find "${tmpdir}" -type f); do
		echo "${i}" | grep -qvE "^${tmpdir}/META-INF/" || continue
		cat <<EOF >>"${tmpdir}/META-INF/CERT.SF"
Name: ${i#${tmpdir}/*}
SHA-256-Digest: $(hex2bin "$(sha256sum "${i}" | awk '{print $1}')" | base64 | tr -d '[:space:]')

EOF
	done

	"${OPENSSL}" smime -sign -binary -noattr -in "${tmpdir}/META-INF/CERT.SF" -outform der -out "${tmpdir}/META-INF/CERT.RSA" -signer "${INSTALLER}/testkey.crt" -md sha256 -inkey "${INSTALLER}/testkey.key"
	#"${OPENSSL}" smime -verify -noverify -content "${tmpdir}/META-INF/CERT.SF" -inform der -in "${tmpdir}/META-INF/CERT.RSA" "${INSTALLER}/testkey.crt"
	"${ZIP}" -r "${apk}" ./META-INF
	#"${ZIP}" -n resources.arsc "${apk}" ./resources.arsc
}

generate_signed_data(){
	local idx=0 apk="${1}" segment_sz=1048576 tmpfile="${INSTALLER}/tmpfile"
	local apk_content="$(od -v -tx1 -An "${apk}" | tr -dc '[0-9a-fA-F]')"
	local eocd_base="$(($(echo -n "${apk_content%504b0506*}" | wc -c)/2))"; unset apk_content
	local cd_base="$(printf '%d' "0x$(od -v -tx1 -An -j$((${eocd_base}+16)) -N4 "${apk}" | tr -c '[0-9a-fA-F]' '\n' | tac | tr -dc '[0-9a-fA-F]')")"
	local cd_size="$(printf '%d' "0x$(od -v -tx1 -An -j$((${eocd_base}+12)) -N4 "${apk}" | tr -c '[0-9a-fA-F]' '\n' | tac | tr -dc '[0-9a-fA-F]')")"

	### ref: https://source.android.com/docs/security/apksigning/v2#signature-algorithm-ids
	#"${OPENSSL}" pkeyutl -sign -in apk.file -inkey "${INSTALLER}/testkey.key" -out sig \
	#	-pkeyopt digest:sha256 -pkeyopt rsa_padding_mode:pss -pkeyopt rsa_pss_saltlen:32 -pkeyopt rsa_mgf1_md:sha256  # 0x0101
	#	-pkeyopt digest:sha512 -pkeyopt rsa_padding_mode:pss -pkeyopt rsa_pss_saltlen:64 -pkeyopt rsa_mgf1_md:sha512  # 0x0102
	#	-pkeyopt digest:sha256 -pkeyopt rsa_padding_mode:pkcs1  # 0x0103
	#	-pkeyopt digest:sha512 -pkeyopt rsa_padding_mode:pkcs1  # 0x0104
	##	key dependent?
	#	-pkeyopt digest:sha256  # 0x0201, ECDSA-SHA2-256
	#	-pkeyopt digest:sha512  # 0x0202, ECDSA-SHA2-512
	#	-pkeyopt digest:sha256  # 0x0301, DSA-SHA2-256
	#	??  # 0x0421, VERITY-RSA-PKCS1-SHA256
	#	 -hexdump?
	#"${OPENSSL}" pkeyutl -verify -in apk.file -sigfile sig -inkey "${INSTALLER}/testkey.key"

	dd bs=1 count="${cd_base}" if="${apk}" of="${INSTALLER}/contents"
	dd bs=1 skip="${cd_base}" count="${cd_size}" if="${apk}" of="${INSTALLER}/cd"
	dd bs=1 skip="${eocd_base}" if="${apk}" of="${INSTALLER}/eocd"

	echo -n >"${tmpfile}"; segment_sz=1048576; while [ $((${idx}*1048576)) -lt ${cd_base} ]; do
		[ $(($((${idx}+1))*1048576)) -lt ${cd_base} ] || segment_sz=$((${cd_base}-$((${idx}*1048576))))
		hex2bin "a5$(byte_split $(printf '%08x' ${segment_sz}) | tac | tr -dc '[0-9a-fA-F]')$(dd bs=1 skip="$((${idx}*1048576))" count="${segment_sz}" if="${INSTALLER}/contents" | sha512sum | awk '{print $1}')" >> "${tmpfile}"
		idx=$((${idx}+1))
	done

	local cd_idx=0 segment_sz=1048576; while [ $((${cd_idx}*1048576)) -lt ${cd_size} ]; do
		[ $(($((${cd_idx}+1))*1048576)) -lt ${cd_size} ] || segment_sz=$((${cd_size}-$((${cd_idx}*1048576))))
		hex2bin "a5$(byte_split $(printf '%08x' ${segment_sz}) | tac | tr -dc '[0-9a-fA-F]')$(dd bs=1 skip="$((${cd_idx}*1048576))" count="${segment_sz}" if="${INSTALLER}/cd" | sha512sum | awk '{print $1}')" >> "${tmpfile}"
		cd_idx=$((${cd_idx}+1))
	done

	local eocd_idx=0 eocd_sz="$(stat -c '%s' "${INSTALLER}/eocd")" segment_sz=1048576
	while [ $((${eocd_idx}*1048576)) -lt ${eocd_sz} ]; do
		[ $(($((${eocd_idx}+1))*1048576)) -lt ${eocd_sz} ] || segment_sz=$((${eocd_sz}-$((${eocd_idx}*1048576))))
		hex2bin "a5$(byte_split $(printf '%08x' ${segment_sz}) | tac | tr -dc '[0-9a-fA-F]')$(dd bs=1 skip="$((${eocd_idx}*1048576))" count="${segment_sz}" if="${INSTALLER}/eocd" | sha512sum | awk '{print $1}')" >> "${tmpfile}"
		eocd_idx=$((${eocd_idx}+1))
	done

	local digest_le="$(hex2bin "5a$(byte_split $(printf '%08x' $((${idx}+${cd_idx}+${eocd_idx}))) | tac | tr -dc '[0-9a-fA-F]')$(od -v -An -tx1 "${tmpfile}" | tr -dc '[0-9a-fA-F]')" | "${OPENSSL}" dgst -hex -c -sha512 | awk '{print $NF}' | tr ':' '\n' | tac | tr -dc '[0-9a-fA-F]')"
	local digest_field="$(byte_split 00000104 | tac | tr -dc '[0-9a-fA-F]')$(byte_split $(printf '%08x' $((${#digest_le}/2))) | tac | tr -dc '[0-9a-fA-F]')${digest_le}"
	local digest_record="$(byte_split $(printf '%08x' $((${#digest_field}/2))) | tac | tr -dc '[0-9a-fA-F]')${digest_field}"
	local digest_seq="$(byte_split $(printf '%08x' $((${#digest_record}/2))) | tac | tr -dc '[0-9a-fA-F]')${digest_record}"

	local cert_len="$("${OPENSSL}" x509 -in "${INSTALLER}/testkey.crt" -outform DER | wc -c)"
	local cert_head="$(byte_split $(printf '%08x' ${cert_len}) | tac | tr -dc '[0-9a-fA-F]')"
	local cert_seq_head="$(byte_split $(printf '%08x' $((${cert_len}+4))) | tac | tr -dc '[0-9a-fA-F]')"

	hex2bin "${digest_seq}${cert_seq_head}${cert_head}" > "${INSTALLER}/signed_data"
	"${OPENSSL}" x509 -in "${INSTALLER}/testkey.crt" -outform DER >> "${INSTALLER}/signed_data"
}

apk_sign(){
	local apk="${1}" min_sdk="$(byte_split $(printf '%08x' 23) | tac | tr -dc '[0-9a-fA-F]')" max_sdk="ffffff7f" attrib_seq="00000000" sdk_spec i block_id

	generate_signed_data "${apk}"

	#CERT="$("${OPENSSL}" pkcs7 -in DD4C077E.RSA -inform DER -print_certs | "${OPENSSL}" x509 -outform DER | od -v -tx1 -An | tr -d '[[:space:]]')"  # definitely works
	#PUBKEY="$("${OPENSSL}" pkcs7 -in DD4C077E.RSA -inform DER -print_certs | "${OPENSSL}" x509 -pubkey -noout | tail -n+2 | head -n-1 | od -v -An -tx1 | tr -d '[[:space:]]')"
	"${OPENSSL}" x509 -in "${INSTALLER}/testkey.crt" -pubkey -noout | tail -n+2 | head -n-1 | base64 -d >"${INSTALLER}/testkey.pub"
	local pub_footer="$(byte_split $(printf '%08x' $(stat -c '%s' "${INSTALLER}/testkey.pub")) | tac | tr -dc '[0-9a-fA-F]')$(od -v -An -tx1 "${INSTALLER}/testkey.pub" | tr -dc '[0-9a-fA-F]')"
	rm "${INSTALLER}/testkey.pub"

	echo -n >"${INSTALLER}/sigblock"
	for i in $(seq 2 3); do
		case "${i}" in
			2)
				block_id="$(byte_split 7109871a | tac | tr -dc '[0-9a-fA-F]')"
			;;
			3)
				block_id="$(byte_split f05368c0 | tac | tr -dc '[0-9a-fA-F]')"
				sdk_spec="${min_sdk}${max_sdk}"
			;;
		esac

		cat "${INSTALLER}/signed_data" > "${INSTALLER}/signed_data.v${i}"
		hex2bin "${sdk_spec}${attrib_seq}" >> "${INSTALLER}/signed_data.v${i}"
		local signed_data="$(byte_split "$(printf '%08x' "$(stat -c '%s' "${INSTALLER}/signed_data.v${i}")")" | tac | tr -dc '[0-9a-fA-F]')$(od -v -An -tx1 "${INSTALLER}/signed_data.v${i}" | tr -dc '[0-9a-fA-F]')"

		#"${OPENSSL}" dgst -hex -c -sha512 -sign "${INSTALLER}/testkey.key" apk.file | awk '{print $NF}' | tr -d ':[:space:]'
		#"${OPENSSL}" x509 -in "${INSTALLER}/testkey.crt" -pubkey -noout | "${OPENSSL}" dgst -sha512 -signature sig -verify /dev/stdin apk.file
		"${OPENSSL}" dgst -sha512 -sign "${INSTALLER}/testkey.key" "${INSTALLER}/signed_data.v${i}" > "${INSTALLER}/signed_data.v${i}.sig"
		local sig_len="$(stat -c '%s' "${INSTALLER}/signed_data.v${i}.sig")"
		local sig_seq="${sdk_spec}$(byte_split $(printf '%08x' $((${sig_len}+12))) | tac | tr -dc '[0-9a-fA-F]')$(byte_split $(printf '%08x' $((${sig_len}+8))) | tac | tr -dc '[0-9a-fA-F]')$(byte_split 00000104 | tac | tr -dc '[0-9a-fA-F]')$(byte_split $(printf '%08x' ${sig_len}) | tac | tr -dc '[0-9a-fA-F]')$(od -v -An -tx1 "${INSTALLER}/signed_data.v${i}.sig" | tr -dc '[0-9a-fA-F]')"
		rm "${INSTALLER}/signed_data.v${i}" "${INSTALLER}/signed_data.v${i}.sig"

		local signer="${signed_data}${sig_seq}${pub_footer}"
		local sigblock="${block_id}$(byte_split $(printf '%08x' $((${#signer}/2+4))) | tac | tr -dc '[0-9a-fA-F]')$(byte_split $(printf '%08x' $((${#signer}/2))) | tac | tr -dc '[0-9a-fA-F]')${signer}"
		hex2bin "$(byte_split $(printf '%016x' $((${#sigblock}/2))) | tac | tr -dc '[0-9a-fA-F]')${sigblock}" >> "${INSTALLER}/sigblock"
	done

	rm "${INSTALLER}/signed_data"
	local sigblock_len="$(byte_split $(printf '%016x' "$(($(stat -c '%s' "${INSTALLER}/sigblock")+24))") | tac | tr -dc '[0-9a-fA-F]')"
	cat "${INSTALLER}/contents" >"${apk}.tmp"
	hex2bin "${sigblock_len}" >>"${apk}.tmp"
	cat "${INSTALLER}/sigblock" >>"${apk}.tmp"
	hex2bin "${sigblock_len}" >>"${apk}.tmp"
	echo -n "APK Sig Block 42" >>"${apk}.tmp"
	sync

	local new_cd_base="$(byte_split $(printf '%08x' "$(stat -c '%s' "${apk}.tmp")") | tac | tr -dc '[0-9a-fA-F]')"
	cat "${INSTALLER}/cd" >>"${apk}.tmp"
	dd bs=1 count=16 if="${INSTALLER}/eocd" >>"${apk}.tmp"
	hex2bin "${new_cd_base}" >>"${apk}.tmp"
	dd bs=1 skip=20 if="${INSTALLER}/eocd" >> "${apk}.tmp"
	mv "${apk}.tmp" "${apk}"
}

##########################################################################################
# privapp permission whitelist generation
##########################################################################################

dump_system_privapp_permissions () {
	local sys_list="${TMPDIR}/privapp-permissions.list"
	local tmp_list="${TMPDIR}/privapp-permissions.dump"

	rm -f "${sys_list}"

	"${AAPT}" dump xmltree /system/framework/framework-res.apk AndroidManifest.xml | \
		tr -d '\n' | sed -e 's/E:/\n/g' > "${tmp_list}"

	for pattern in	"(type 0x11)0x[1357]2" "(type 0x11)0xc212" \
			"(type 0x11)0x[02]" "(type 0x11)0x[13]02"  \
			"(type 0x11)0x1[01]2" "(type 0x11)0x1001"  \
			"(type 0x11)0x[15]2" "(type 0x11)0x1000072"; do
		grep "${pattern}" "${tmp_list}" | \
		awk -F\" '{print $2}' >> "${sys_list}"
	done
}

create_privapp_permissions_whitelist () {
	local apk="${MODPATH}${INSTPART}/priv-app/${1}/${1}.apk"
	local apk_name="$("${AAPT}" dump badging "${apk}" | awk -F \' '/^package: name/{print $2}')"
	local apk_list="${TMPDIR}/${apk_name}.list"

	local sys_list="${TMPDIR}/privapp-permissions.list"

	local app_whitelist="${TMPDIR}/${apk_name}.xml"
	local inst_whitelist="${INSTPART}/etc/permissions/${apk_name}.xml"

	[ ! -f "${sys_list}" ] && dump_system_privapp_permissions

	"${AAPT}" dump permissions "${apk}" | \
		awk -F \' '/^uses-permission:/{print $2}' > "${apk_list}"

	echo '<?xml version="1.0" encoding="utf-8"?>
<permissions>
	<privapp-permissions package="'${apk_name}'">' > "${app_whitelist}"

	cat "${apk_list}" | while read perm; do
		if grep -q "${perm}" "${sys_list}"; then
			decho "  ++ package ${apk_Name} needs privapp-whitelist ${perm}"
			echo '        <permission name="'${perm}'" />' >> "${app_whitelist}"
		fi
	done

	echo '    </privapp-permissions>
</permissions>' >> "${app_whitelist}"

	mkdir -p "${MODPATH}${INSTPART}/etc/permissions/"
	cp "${app_whitelist}" "${MODPATH}/${inst_whitelist}"
	set_perm_data "${MODPATH}/${inst_whitelist}"
	installinfo_add "${inst_whitelist}"
}

##########################################################################################
# Reset System Runtime permissions
##########################################################################################

reset_runtime_permissions () {
	# required on Android 10, else all apps bundled with NanoDroid will not
	# show a permission prompt for android.permission.WRITE_EXTERNAL_STORAGE
	if [ "${SDK_VERSION}" -ge 29 ]; then
		if "${BOOTMODE}"; then
			pm reset-permissions
		else
			find /data/system/users -type f -name 'runtime-permissions.xml' 2>/dev/null | while read file; do
				rm -f "${file}"
				decho "  ++ resetting permissions: ${file}"
			done
		fi
	fi
}

##########################################################################################
# Unpack NanoDroid zip
##########################################################################################

unpack_zip () {
	TMPDIR=/dev/tmp
	TMP_LIBDIR="${TMPDIR}/nanodroid-lib"
	INSTALLER="${TMPDIR}/install"

	rm -rf "${INSTALLER}"
	mkdir -p "${INSTALLER}" || error "failed to prepare environment!"

	print_info " > prepare installation"
	unzip -oq "${ZIP}" -d "${INSTALLER}" || \
		error "failed to prepare environment!"

	rm -rf "${TMPDIR}/framework-res"
	rm -f "${TMPDIR}/"*.xml
	rm -f "${TMPDIR}/"*.list

	chmod 0755 "${INSTALLER}/"*.*
}

##########################################################################################
# Print NanoDroid banner
##########################################################################################

show_banner () {
	print_info " "
	print_info "*****************************"
	print_info " NanoDroid                   "
	case "${MODID}" in
		NanoDroid )
			print_info " > Full package              "
		;;
		NanoDroid_${MODID#*_} )
			print_info " > ${MODID#*_} package   "
		;;
	esac

	if [ "${ZIP}" == *${VERSION}* ]; then
		print_info " ${VERSION}                  "
	else
		print_info " ${VERSION} (snapshot)       "
	fi

	print_info "*****************************"
	print_info " "
}

##########################################################################################
# Architecture detection
##########################################################################################

detect_arch () {
	SDK_VERSION="$(grep_prop ro.build.version.sdk)"

	ABI="$(grep_prop ro.product.cpu.abi | cut -c-3)"
	ABI2="$(grep_prop ro.product.cpu.abi2 | cut -c-3)"
	ABILONG="$(grep_prop ro.product.cpu.abi)"

	ARCH=arm

	[ "${ABI}" = "x86" ] && ARCH=x86
	[ "${ABI2}" = "x86" ] && ARCH=x86
	[ "${ABILONG}" = "arm64-v8a" ] && ARCH=arm64
	[ "${ABILONG}" = "x86_64" ] && ARCH=x86_64

	case "${ARCH}" in
		arm )		BIN_ARCH="arm"
				LIB_ARCHES="armeabi-v7a armeabi"
		;;
		arm64 )		BIN_ARCH="arm"
				LIB_ARCHES="arm64-v8a armeabi-v7a armeabi"
		;;
		x86 )		BIN_ARCH="x86"
				LIB_ARCHES="x86 armeabi-v7a armeabi"
		;;
		x86_64 )	BIN_ARCH="x86"
				LIB_ARCHES="x86_64 x86 armeabi-v7a armeabi"
		;;
	esac

	UNZIP="${INSTALLER}/unzip.${BIN_ARCH}"
	AAPT="${INSTALLER}/aapt.${BIN_ARCH}"
	ZSTD="${INSTALLER}/zstd.${BIN_ARCH}"
	OPENSSL="${INSTALLER}/openssl.${BIN_ARCH}"
	ZIP="${INSTALLER}/zip.${BIN_ARCH}"
	ZIPALIGN="${INSTALLER}/zipalign.${BIN_ARCH}"
	chmod +x "${UNZIP}" "${AAPT}" "${ZSTD}"

	if [[ "${SDK_VERSION}" -lt 21 ]]; then
		UNFOLD_APP_DIR=1
	else	UNFOLD_APP_DIR=0
	fi

	if [[ "${SDK_VERSION}" -lt 19 ]]; then
		print_info " "
		print_info " ++ Installing on pre-KitKat ROM, full"
		print_info " ++ compatibility is not guaranteed!"
		print_info " "
	fi

	[ ! -d /data/adb ] && mkdir /data/adb
}

##########################################################################################
# Detect and setup partition to systemize non-essential components into
##########################################################################################

detect_capacity () {
	[ "${MODE}" != "SYSTEM" ] && echo "/system" || case "${MODID}" in
		NanoDroid_microG | NanoDroid_Google ) echo "/system";;
		*) df /system_root /system /system_ext /product | grep -vE '^Filesystem|/$' | sort -nrk 4 | awk '{print $NF}' | sed 's/system_root/system/' | sort -u | head -n1;;
	esac
}

##########################################################################################
# Detect and setup installation mode
##########################################################################################

detect_mode () {
	# migrate old list to new location
	[ -f /data/adb/NanoDroid_FileList ] && mv /data/adb/NanoDroid_FileList "${NANODROID_LIST}"

	case "${nanodroid_forcesystemize}" in
		1 )
			if "${BOOTMODE}"; then
				print_info "nanodroid_forcesystemize set to true"
				error "can't install to /system from Magisk Manager"
			fi
			MODE_DETECT=forced
			MODE=SYSTEM
		;;

		0 | *)
			MODE_DETECT=detected
			MODE=SYSTEM

			if "${BOOTMODE}"; then
				[ ! -f /data/adb/magisk/util_functions.sh ] || . /data/adb/magisk/util_functions.sh
				[ ! -f /data/magisk/util_functions.sh ] || . /data/magisk/util_functions.sh
				[ "${MAGISK_VER_CODE:-0}" -lt 19000 ] || MODE=MAGISK
			fi
		;;
	esac

	print_info " > Mode   | ${MODE}            | ${MODE_DETECT}"
	print_info " "

	case "${MODE}" in
		SYSTEM )
			installer_setup_env
			unset MODPATH

			mkdir -p /system/addon.d
			[ -f "${NANODROID_LIST}" ] && NANODROID_UPGRADE=1
		;;

		MAGISK )
			magisk_install_setup
			[ "${MODID}" != "NanoDroid" ] || magisk_install_preinst
		;;
	esac

	local instpart="$(detect_capacity)"
	[ -z "${instpart}" ] || INSTPART="${instpart}"

	NANODROID_BINDIR="${MODPATH}/system/bin"
}

##########################################################################################
# Finalize NanoDroid Installation
##########################################################################################

nanodroid_finalize () {
	if [ "${MODID}" = "NanoDroid" ]; then
		if [ "${nanodroid_overlay}" -eq 1 ]; then
			print_info " << with /system applications overlays"
			"${NANODROID_BINDIR}/nanodroid-overlay" --create
		else
			print_info " << without /system applications overlays"
		fi
	fi

	if [ "${MODE}" = "MAGISK" ]; then
		magisk_install_finish
	else
		install_addond
		sync
		nanodroid_storelogs

		sort "${NANODROID_LIST}" | uniq > /tmp/nanodroid-list
		mv /tmp/nanodroid-list "${NANODROID_LIST}"

		installer_cleanup_env
	fi

	[ "${NANODROID_UPGRADE}" -eq 0 ] && reset_runtime_permissions

	print_info " "
	print_info " Thanks for using NanoDroid "
	print_info " "

	"${BOOTMODE}" || umount_partitions

	rm -rf "${INSTALLER}"
}

##########################################################################################
# Setup Environment
##########################################################################################

##########################################################################################
# Setup Busybox
##########################################################################################

setup_busybox () {
	case "$(uname -m)" in
		arm* | aarch* )	local bb_arch=arm ;;
		x86* )	local bb_arch=x86 ;;
		*    ) error "arch \"$(uname -m)\" is not supported"
	esac

	mkdir -p "${INSTALLER}/busybox"
	ln -s "${INSTALLER}/busybox.${bb_arch}" "${INSTALLER}/busybox/busybox"

	chmod 0755 "${INSTALLER}/busybox.${bb_arch}"
	"${INSTALLER}/busybox.${bb_arch}" --install -s "${INSTALLER}/busybox/"

	OLD_PATH="${PATH}"
	export PATH="${INSTALLER}/busybox:/system/bin:/vendor/bin"
}

##########################################################################################
# Move envvars out of the way
##########################################################################################
installer_setup_env () {
	if ! "${BOOTMODE}"; then
		OLD_PATH="${PATH}"
		OLD_LD_LIB="${LD_LIBRARY_PATH}"
		OLD_LD_PRE="${LD_PRELOAD}"
		OLD_LD_CFG="${LD_CONFIG_FILE}"
		unset LD_LIBRARY_PATH
		unset LD_PRELOAD
		unset LD_CONFIG_FILE
	fi
}

##########################################################################################
# Restore envvars
##########################################################################################
installer_cleanup_env () {
	if "${BOOTMODE}"; then
		[ -n "${OLD_PATH}" ] && PATH="${OLD_PATH}"
	else
		[ -n "${OLD_PATH}" ] && PATH="${OLD_PATH}"
		[ -n "${OLD_LD_LIB}" ] && LD_LIBRARY_PATH="${OLD_LD_LIB}"
		[ -n "${OLD_LD_PRE}" ] && LD_PRELOAD="${OLD_LD_PRE}"
		[ -n "${OLD_LD_CFG}" ] && LD_CONFIG_FILE="${OLD_LD_CFG}"
	fi
}

##########################################################################################
# Magisk Mode Installation
##########################################################################################

##########################################################################################
# Setup Magisk Mode Installation
##########################################################################################

magisk_install_setup () {
	print_info " "
	print_info "******************************"
	print_info "Powered by Magisk (@topjohnwu)"
	print_info "******************************"
	print_info " "
	print_info " > setup Magisk environment"

	MAGISKBASE=/data/adb
	installer_setup_env

	case "${MODID}" in
		NanoDroid )
			# check for sub-modules  which are not
			# supposed to be installed alongside
			[ -d "${MAGISKBASE}/modules/NanoDroid_FDroid" ] && NANODROID_UPGRADE=1
			for mod_dir in modules modules_update; do
				if [ -d "${MAGISKBASE}/${mod_dir}/NanoDroid_FDroid" ]; then
					print_info " !! NanoDroid_FDroid module detected - uninstalling!"
					rm -rf "${MAGISKBASE}/${mod_dir}/NanoDroid_FDroid"
				fi
			done
		;;

		NanoDroid_FDroid )
			# check for Full package and abort if found
			for mod_dir in modules modules_update; do
				[ -d "${MAGISKBASE}/${mod_dir}/NanoDroid" ] && error "${MODID} can't be installed along side the Full package"
			done
		;;

		NanoDroid_OsmAnd | NanoDroid_BromiteWebView | NanoDroid_MulchWebView | NanoDroid_CromiteWebView ) :;;

		* )
			error "unknown module intended to be installed!?"
		;;
	esac

	[ -d "${MODPATH}" ] && NANODROID_UPGRADE=1

	[ "${NANODROID_UPGRADE}" -eq 1 ] && MODPATH="${MAGISKBASE}/modules_update/${MODID}" && rm -rf "${MODPATH}" || MODPATH="${MAGISKBASE}/modules/${MODID}"
}

##########################################################################################
# Magisk Mode Installation: Pre-Installation Tasks
##########################################################################################

magisk_install_preinst () {
	if [ -f "${MODPATH}/system.prop" ]; then
		print_info " << backing up module's system.prop"
		cp "${MODPATH}/system.prop" "${TMPDIR}/system.prop"
	fi

	if [ -d "${MODPATH}/logs" ]; then
		print_info " << backing up init.d script logs"
		cp -r "${MODPATH}/logs" "${TMPDIR}/logs"
	fi

	if [ -d "${MODPATH}/logcats" ]; then
		print_info " << backing up logcats"
		cp -r "${MODPATH}/logcats" "${TMPDIR}/logcats"
	fi
}

##########################################################################################
# Magisk Mode Installation: Post-Installation Tasks
##########################################################################################

magisk_install_postinst () {
	if [ -f "${TMPDIR}/system.prop" ]; then
		print_info " << restoring system.prop"
		cp "${TMPDIR}/system.prop" "${MODPATH}/system.prop"
	fi

	if [ -d "${TMPDIR}/logs" ]; then
		print_info " << restoring init.d script logs"
		cp -r "${TMPDIR}/logs" "${MODPATH}/logs"
	fi

	if [ -d "${TMPDIR}/logcats" ]; then
		print_info " << restoring logcats"
		cp -r "${TMPDIR}/logcats" "${MODPATH}/logcats"
	fi
}

##########################################################################################
# Finalize Magisk Mode Installation
##########################################################################################

magisk_install_finish () {
	# Magisk Module files
	cp -af "${INSTALLER}/module.prop" "${MODPATH}/module.prop"

	if [ -f "${INSTALLER}/service.sh" ]; then
		cp -af "${INSTALLER}/service.sh" "${MODPATH}/service.sh"
		chmod +x "${MODPATH}/service.sh"
	fi

	[ "${MODID}" != "NanoDroid" ] || magisk_install_postinst

	if "${BOOTMODE}"; then
		touch "${MAGISKBASE}/modules/${MODID}/update" 2>/dev/null
		cp -af "${INSTALLER}/module.prop" "${MAGISKBASE}/modules/${MODID}/module.prop" 2>/dev/null
	fi

	sync
	nanodroid_storelogs
	installer_cleanup_env
}

##########################################################################################
# Generic Installation
##########################################################################################

##########################################################################################
# Install Applications
##########################################################################################

install_apps () {
	local i
	# install apps if requested
	if [ "${nanodroid_apps}" -eq 1 ]; then
		print_info " << with applications"
		APP_STRING=" <<>"

		if ! "${BOOTMODE}" && [ -n "${nanodroid_forcepart}" ]; then
			local old_instpart="${INSTPART}"
			INSTPART="${nanodroid_forcepart}"
		fi
		grep -E -v '^(#|[[:space:]]*$)' "${cfg_apps}" | while read app; do
			for i in app priv-app; do
				if [ -d "${INSTALLER}/system/${i}/${app}" ]; then
					print_info "   ++ ${app}"
					nanodroid_install_apk "${app}"
				fi
			done
		done
		"${BOOTMODE}" || [ -z "${nanodroid_forcepart}" ] || INSTPART="${old_instpart}"
	else	print_info " << without applications"
	fi
}

##########################################################################################
# Install NanoDroid Scripts
##########################################################################################

install_nanodroidscripts () {
	print_info " << with NanoDroid Scripts"

	if ! "${BOOTMODE}" && [ -n "${nanodroid_forcepart}" ]; then
		local old_instpart="${INSTPART}"
		INSTPART="${nanodroid_forcepart}"
	fi
	nanodroid_install_file bin/nanodroid-overlay bin
	nanodroid_substitute bin/nanodroid-overlay
	"${BOOTMODE}" || [ -z "${nanodroid_forcepart}" ] || INSTPART="${old_instpart}"
}

##########################################################################################
# Install init scripts
##########################################################################################

install_initd () {
	if [ -n "${nanodroid_init}" ]; then
		print_info " << with init scripts"

		if [ "${MODE}" = "SYSTEM" ]; then
			INIT_BASE="${MODPATH}/system/etc/init.d"
		else	INIT_BASE="${MODPATH}/init.d"
		fi

		mkdir -p "${INIT_BASE}"

		for script in ${nanodroid_init}; do
			if [ -f "${INSTALLER}/system/etc/init.d/${script}" ]; then
				cp "${INSTALLER}/system/etc/init.d/${script}" "${INIT_BASE}/"
				set_perm_bin "${INIT_BASE}/${script}"
				installinfo_add "/system/etc/init.d/${script}"
			else
				ui_print " -- ${script} is not a known init script"
			fi
		done
	else	print_info " << without init scripts"
	fi
}

##########################################################################################
# Install System WebView
##########################################################################################

install_webview () {
	if [ "${MODID}" = "NanoDroid_BromiteWebView" ] || [ "${MODID}" = "NanoDroid_MulchWebView" ] || [ "${MODID}" = "NanoDroid_CromiteWebView" ]; then
		local init_base overlaydir lib_suffix i multilib
		[ "$(uname -m)" = "aarch64" ] && lib_suffix=64
		[ "$(uname -m)" = "x86_64"  ] && lib_suffix=64
		for i in system_ext/overlay product/overlay overlay; do
			[ -d "/system/${i}" ] && overlaydir="${i}" && break
		done
		:||{
		mkdir -p "${TMPDIR}/syswebview/res/xml" "${INSTALLER}/system/${overlaydir}"
		[ -z "${WEBVIEW_SIG}" ] || _signature="<signature>${WEBVIEW_SIG}</signature>"
		"${AAPT}" dump xmltree /system/framework/framework-res.apk res/xml/config_webview_packages.xml | \
			parse_aapt_dump_xmltree | sed "s|</webviewproviders>|<webviewprovider availableByDefault=\"true\" description=\"${WEBVIEW_DESC}\" packageName=\"${WEBVIEW_PKG}\">${_signature}</webviewprovider></webviewproviders>|g" > "${TMPDIR}/syswebview/res/xml/config_webview_packages.xml"
		"${AAPT}" package -f -M "${INSTALLER}/AndroidManifest.xml" -I /system/framework/framework-res.apk -S "${TMPDIR}/syswebview/res" -F "${TMPDIR}/SystemWebviewOverlay.apk" --target-sdk-version "$(grep_prop ro.system.build.version.sdk)"
		"${ZIPALIGN}" 4 "${TMPDIR}/SystemWebviewOverlay.apk" "${INSTALLER}/system/${overlaydir}/SystemWebviewOverlay.apk"
		jar_sign "${INSTALLER}/system/${overlaydir}/SystemWebviewOverlay.apk"
		apk_sign "${INSTALLER}/system/${overlaydir}/SystemWebviewOverlay.apk"
		}
		print_info " << with ${MODID#*_}"

		case "${ARCH}" in
			arm | arm64 | x86 ) SYSWEBVIEW_ARCH="${ARCH}" ;;
			x86_64 ) SYSWEBVIEW_ARCH=x86 ;;
		esac

		if [ "${NANODROID_UPGRADE}" -eq 0 ]; then
			rm -rf "/data/data/${WEBVIEW_PKG:-org.bromite.webview}"
			rm -rf "/data/user/"*"/${WEBVIEW_PKG:-org.bromite.webview}"
			rm -rf "/data/user_de/"*"/${WEBVIEW_PKG:-org.bromite.webview}"
			rm -rf "/data/app/${WEBVIEW_PKG:-org.bromite.webview}-"*
			rm -rf "/mnt/asec/${WEBVIEW_PKG:-org.bromite.webview}-"*
			rm -rf "${STORAGE}/Android/data/${WEBVIEW_PKG:-org.bromite.webview}"
		fi

		if ! "${BOOTMODE}" && [ -n "${nanodroid_forcepart_webview}" ]; then
			local old_instpart="${INSTPART}"
			INSTPART="${nanodroid_forcepart_webview}"
		fi
		[ "${nanodroid_webview_multilib}" -ne 1 ] || multilib="multilib"
		nanodroid_install_apk "${MODID#*_}_${SYSWEBVIEW_ARCH}" "${MODID#*_}" "${multilib}"
		case "${INSTPART}" in
			/system)	INSTPART=/system;;
			/system_root)	INSTPART=/system;;
			*)		INSTPART=/;;
		esac
		mkdir -p "${MODPATH}${INSTPART}/${overlaydir}/"
		cp "${INSTALLER}/SystemWebviewOverlay.apk" "${MODPATH}${INSTPART}/${overlaydir}/SystemWebviewOverlay.apk"
		set_perm_data "${MODPATH}${INSTPART}/${overlaydir}/SystemWebviewOverlay.apk"
		"${BOOTMODE}" || [ -z "${nanodroid_forcepart_webview}" ] || INSTPART="${old_instpart}"
	fi
}

##########################################################################################
# SYSTEM MODE addon.d
##########################################################################################

install_addond () {
	print_info " << System Mode OTA survival"

	cp "${INSTALLER}/CommonAddon" "/system/addon.d/91-nanodroid.sh" || \
		error "failed to install System Mode OTA survival"

	chmod 0755 "/system/addon.d/91-nanodroid.sh"
}

##########################################################################################
# Advanced Installation Functions
##########################################################################################

##########################################################################################
# Create Uninstaller / addon.d filelist for SYSTEM MODE
##########################################################################################

installinfo_add () {
	[ "${MODE}" != "SYSTEM" ] || for file in "${@}"; do
		echo "${file}" >> "${NANODROID_LIST}"
	done
}

##########################################################################################
# NanoDroid installation function for files
##########################################################################################

nanodroid_install_file () {
	dir="$(dirname "${1}")"
	file="$(basename "${1}")"
	unset source

	if [ -f "${INSTALLER}/system/${dir}/${file}" ]; then
		source="${INSTALLER}/system/${dir}/${file}"
		break
	fi

	[ -z "${source}" ] && error "file: ${file} not found"

	# strip off .${BIN_ARCH} from final filename (if any)
	xfile="$(basename "${file}" .${BIN_ARCH})"

	decho "    installing file: ${xfile}"

	mkdir -p "${MODPATH}${INSTPART}/${dir}/"
	cp "${source}" "${MODPATH}${INSTPART}/${dir}/${xfile}" || \
		error "failed to install ${xfile}"

	case "${2}" in
		bin ) set_perm_bin "${MODPATH}${INSTPART}/${dir}/${xfile}" ;;
		*   ) set_perm_data "${MODPATH}${INSTPART}/${dir}/${xfile}" ;;
	esac

	installinfo_add "${INSTPART}/${dir}/${xfile}"
}

##########################################################################################
# NanoDroid installation function for directories
##########################################################################################

nanodroid_install_dir () {
	dir="${1}"
	[ -n "${2}" ] && dest="${2}" || dest="${INSTPART}/${dir}"

	[ ! -d "${INSTALLER}/system/${dir}" ] && \
		error "dir: ${dir} not found"

	echo "    installing dir: ${dir}"

	mkdir -p "${MODPATH}${dest}"
	cp -r "${INSTALLER}/system/${dir}"/* "${MODPATH}${dest}/" || \
		error "failed to install ${dir}"

	case "${2}" in
		bin ) set_perm_bin -r "${MODPATH}${dest}" ;;
		*   ) set_perm_data -r "${MODPATH}${dest}" ;;
	esac

	find "${INSTALLER}/system/${dir}" -type f | \
		sed -e "s,^${INSTALLER}/system,${INSTPART},g" | \
		installinfo_add
}

##########################################################################################
# NanoDroid installation function for APKs
##########################################################################################

nanodroid_install_apk () {
	app="${1}"
	alias="${2}"

	unset prefix
	unset source

	for sdir in system/app system/priv-app; do
		if [ -f "${INSTALLER}/${sdir}/${app}/${app}.apk.zst" ]; then
			source="${INSTALLER}/${sdir}/${app}/${app}.apk"
			dir="${INSTPART#/}/$(basename "${sdir}")"
			break
		fi
	done

	[ -z "${source}" ] && error "app ${app} not found"

	if [ "${UNFOLD_APP_DIR}" -eq 1 ]; then
		dest="${MODPATH}/${dir}"
	else
		if [ -z "${alias}" ]; then
			dest="${MODPATH}/${dir}/${app}"
		else	dest="${MODPATH}/${dir}/${alias}"
		fi
	fi

	if [ -n "${alias}" ]; then
		dest_apk="${alias}.apk"
	else	dest_apk="${app}.apk"
	fi

	mkdir -p "${dest}"

	decho "    installing app: ${app}"
	decho "      from: ${source}"
	decho "      into: ${dest} [${dest_apk}]"
	"${ZSTD}" -fd -o "${dest}/${dest_apk}" "${source}.zst" || \
		error "failed to install ${dest}/${dest_apk}"

	installinfo_add "${dest}/${dest_apk}"

	nanodroid_install_lib "${dest}/${dest_apk}" "${3}"

	[ "${sdir}" = "system/priv-app" ] && create_privapp_permissions_whitelist "${app}"

	set_perm_data -r "${dest}"
}

##########################################################################################
# NanoDroid installation function for libraries
##########################################################################################

nanodroid_install_lib () {
	apk="${1}"
	dest="$(dirname "$1")"
	multilib="${2}"

	unset libd

	if [ "${UNFOLD_APP_DIR}" -eq 1 ]; then
		case "${ARCH}" in
			arm | x86 )      libd="${MODPATH}${INSTPART}/lib"   ;;
			arm64 | x86_64 ) libd="${MODPATH}${INSTPART}/lib64" ;;
		esac
	else
		libd="${dest}/lib"
	fi

	rm -rf "${TMP_LIBDIR}"
	mkdir -p "${TMP_LIBDIR}"

	unset srcdir

	"${UNZIP}" -oq "${apk}" "lib/*" -d "${TMP_LIBDIR}" \
		2>/dev/null
	unzip_return="${?}"

	case "${unzip_return}" in
		0  ) decho "      ${app} does have libs" ;;
		11 ) decho "      ${app} does not have any libs" ;;
		50 ) error "  not enough space available!" ;;
		*  ) error "  unpacking libs for ${app} failed [${unzip_return}]" ;;
	esac

	if [ -d "${TMP_LIBDIR}/lib" ]; then
		for ARCHLIB in ${LIB_ARCHES}; do
			if [ -d "${TMP_LIBDIR}/lib/${ARCHLIB}" ]; then
				srcdir="${TMP_LIBDIR}/lib/${ARCHLIB}"

				case "${srcdir}" in
					*arm64*  ) decho "      ${app}: installing arm64 libs"
						   lib_arch=arm64 ;;
					*arm*	 ) decho "      ${app}: installing arm libs"
						   lib_arch=arm ;;
					*x86_64* ) decho "      ${app}: installing x86_64 libs"
						   lib_arch=x86_64 ;;
					*x86*	 ) decho "      ${app}: installing x86 libs"
						   lib_arch=x86 ;;
				esac

				decho "        from: ${srcdir}"
				decho "        into: ${libd}/${lib_arch}"
				mkdir -p "${libd}/${lib_arch}"

				for lib in "${srcdir}/"*; do
					decho "        library: $(basename "${lib}")"
					cp "${lib}" "${libd}/${lib_arch}/" || \
						error "  installing libs for ${app} failed"

					installinfo_add "${libd}/${lib_arch}/$(basename "${lib}")"
				done

				[ -z "${multilib}" ] && break
			fi
		done
	fi
}

##########################################################################################
# substitute values in installed files
##########################################################################################

nanodroid_substitute () {
	dir="$(dirname "${1}")"
	file="$(basename "${1}")"

	target="${MODPATH}${INSTPART}/${dir}/${file}"

	[ ! -f "${target}" ] && error "file: ${file} not found"

	if grep -q @MODPATH@ "${target}"; then
		sed -e "s|@MODPATH@|${MODPATH}|g" -i "${target}"
		decho "    substitute: adjust @MODPATH@ in ${target}"
	fi

	if grep -q @MODID@ "${target}"; then
		sed -e "s|@MODID@|${MODID}|g" -i "${target}"
		decho "    substitute: adjust @MODID@ in ${target}"
	fi

	if grep -q @MODE@ "${target}"; then
		sed -e "s|@MODE@|${MODE}|g" -i "${target}"
		decho "    substitute: adjust @MODE@ in ${target}"
	fi
}

##########################################################################################
# create installation logs
##########################################################################################

nanodroid_storelogs () {
	mkdir -p "${STORAGE}/nanodroid_logs"

	echo "\

Installation successful: ${INSTALL_SUCCESS}

### VALUES ###
ZIP=${ZIP}
TMPDIR=${TMPDIR}
TMP_LIBDIR=${TMP_LIBDIR}
INSTALLER=${INSTALLER}
MODID=${MODID}
SDK_VERSION=${SDK_VERSION}
ARCH=${ARCH}
LIB_ARCHES=${LIB_ARCHES}
MODPATH=${MODPATH}
MODE=${MODE}
MAGISK_VER_CODE=${MAGISK_VER_CODE}
NANODROID_UPGRADE=${NANODROID_UPGRADE}
NANODROID_BINDIR=${NANODROID_BINDIR}

### MOUNTED PARTITIONS ###
" >> "${nanodroid_logfile}"

mount | awk '{print $1 " on " $3 " params: " $6}' \
	>> "${nanodroid_logfile}"

echo "
### PARTITION INFORMATION ###

DEVICE_AB=${DEVICE_AB}
VENDOR_COMPAT=${VENDOR_COMPAT}
SYSTEM_AS_ROOT=${SYSTEM_AS_ROOT}
SYSTEM_BLOCK=${SYSTEM_BLOCK}
VENDOR_BLOCK=${VENDOR_BLOCK}

### DISK USAGE ###
" >> "${nanodroid_logfile}"

df 2>/dev/null | sed '/^\//d' >> "${nanodroid_logfile}"

if [ -n "${cfg_setup}" ]; then

echo "
### SETUP ###

configuration: ${cfg_setup}
" >> "${nanodroid_logfile}"

cat "${cfg_setup}" >> "${nanodroid_logfile}"

fi

if [ -n "${cfg_apps}" ]; then

echo "
### APPS ###

configuration: ${cfg_apps}
" >> "${nanodroid_logfile}"

cat "${cfg_apps}" >> "${nanodroid_logfile}"

fi

if [ -n "${cfg_overlay}" ]; then

echo "
### OVERLAY ###

configuration: ${cfg_overlay}
" >> "${nanodroid_logfile}"

cat "${cfg_overlay}" >> "${nanodroid_logfile}"

fi

chown root:sdcard_rw "${nanodroid_logfile}"
chmod 0644 "${nanodroid_logfile}"

print_info " | storing installation logs in ${STORAGE}/nanodroid_logs/"
print_info " | NanoDroid log:"
print_info " || ""$(basename "${nanodroid_logfile}")"

	if [ -d /twres ]; then
		nanodroid_twrplog="${STORAGE}/nanodroid_logs/${MODID}_${VERSION}_twrp_${curdate}.log"

		cat /tmp/recovery.log > "${nanodroid_twrplog}"

		chown root:sdcard_rw "${nanodroid_twrplog}"
		chmod 0644 "${nanodroid_twrplog}"

		print_info " | TWRP log:"
		print_info " || $(basename "${nanodroid_twrplog}")"
		print_info " "
	fi

}

##########################################################################################
# NanoDroid Configuration File Handling
##########################################################################################

get_config () {
	config=""
	config_exists=0
	for path in ${config_locations}; do
		if test -r "${path}/.nanodroid-${1}"; then
			config="${path}/.nanodroid-${1}"
			config_exists=1
			return
		fi
	done
}

set_prop () {
	echo "${1}=${2}" >> "${cfg_setup}"
}

##########################################################################################
# Load and verify .nanodroid-setup configuration file
##########################################################################################

get_cfg_setup () {
	get_config setup
	if [ "${config_exists}" -eq 1 ]; then
		cfg_setup="${config}"
		check_cfg_setup
		print_info " > Config | nanodroid-setup   | $(dirname "${cfg_setup}")"
	else
		cfg_setup="${INSTALLER}/.nanodroid-setup"
		source "${cfg_setup}"
		print_info " > Config | nanodroid-setup   | fallback"
	fi
}

# check whether '.nanodroid-setup' has all required entries
check_cfg_setup () {
	# see https://gitlab.com/Nanolx/NanoDroid/-/issues/147
	dos2unix "${cfg_setup}" &>/dev/null

	source "${cfg_setup}"

	[ -z "${nanodroid_fdroid}" ] && set_prop nanodroid_fdroid 1
	[ -z "${nanodroid_apps}" ] && set_prop nanodroid_apps 1
	[ -z "${nanodroid_overlay}" ] && set_prop nanodroid_overlay "$([ "${MODID}" != "NanoDroid" ]; echo "${?}")"
	[ -z "${nanodroid_forcesystemize}" ] && set_prop nanodroid_forcesystemize 0
	[ -z "${nanodroid_init+x}" ] && set_prop nanodroid_init "${nanodroid_all_init}"

	# in NanoDroid 22.7 nanodroid_init has changed
	if [ "${#nanodroid_init}" -eq 1 ]; then
		sed -e '/^nanodroid_init/d' -i "${cfg_setup}"
		set_prop nanodroid_init "${nanodroid_all_init}"
	fi

	source "${cfg_setup}"
}

##########################################################################################
# Load and verify .nanodroid-overlay configuration file
##########################################################################################

get_cfg_overlay () {
	get_config overlay
	if [ "${config_exists}" -eq 1 ]; then
		cfg_overlay="${config}"
		check_cfg_overlay
		print_info " > Config | nanodroid-overlay | $(dirname "${cfg_overlay}")"
	else
		cfg_overlay="${INSTALLER}/.nanodroid-overlay"
		print_info " > Config | nanodroid-overlay | fallback"
	fi
}

# check whether '.nanodroid-overlay' is up to date
check_cfg_overlay () {
	# see https://gitlab.com/Nanolx/NanoDroid/-/issues/147
	dos2unix "${cfg_overlay}" &>/dev/null
}

##########################################################################################
# Load and verify .nanodroid-apps configuration file
##########################################################################################

get_cfg_apps () {
	get_config apps
	if [ "${config_exists}" -eq 1 ]; then
		cfg_apps="${config}"
		print_info " > Config | nanodroid-apps    | $(dirname "${cfg_apps}")"
	else
		cfg_apps="${INSTALLER}/.nanodroid-apps"
		print_info " > Config | nanodroid-apps    | fallback"
	fi
}
